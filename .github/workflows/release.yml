name: Create Release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-rc*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all commits and tags
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24.4'
    
    - name: Determine release type
      id: release-type
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual dispatch - create next version tag
          echo "manual_dispatch=true" >> $GITHUB_OUTPUT
        else
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "manual_dispatch=false" >> $GITHUB_OUTPUT
          
          # Check if this is a pre-release (contains -rc. or -rc)
          if [[ "$TAG_NAME" == *"-rc."* ]] || [[ "$TAG_NAME" == *"-rc"* ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "release_type=Pre-release" >> $GITHUB_OUTPUT
          else
            # Check if this is a major release (*.0.0)
            if [[ "$TAG_NAME" =~ ^v[0-9]+\.0\.0$ ]]; then
              echo "is_prerelease=false" >> $GITHUB_OUTPUT
              echo "release_type=Major Release" >> $GITHUB_OUTPUT
            else
              echo "is_prerelease=false" >> $GITHUB_OUTPUT
              echo "release_type=Release" >> $GITHUB_OUTPUT
            fi
          fi
        fi
        
        echo "Release type determined for: $TAG_NAME"

    - name: Get last non-pre-release tag (manual dispatch)
      id: last-release-tag
      if: steps.release-type.outputs.manual_dispatch == 'true'
      run: |
        # Fetch all tags and filter for non-pre-release tags
        non_pre_release_tags=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname)

        # Get the last non-pre-release tag
        last_non_pre_release_tag=$(echo "$non_pre_release_tags" | head -n 1)

        if [ -z "$last_non_pre_release_tag" ]; then
          # If no non-pre-release tags found, get the last pre-release tag
          last_pre_release_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*-rc*' --sort=-v:refname | head -n 1)
          
          if [ -z "$last_pre_release_tag" ]; then
            # If no tags found at all, create the initial version
            new_tag="v0.0.1"
          else
            # Extract major, minor, and patch components from the last pre-release tag
            version_without_v=${last_pre_release_tag#v}
            version_without_rc=${version_without_v%-rc.*}
            new_tag="v$version_without_rc"
          fi
        else
          # Extract major, minor, and patch components from the last non-pre-release tag
          version_without_v=${last_non_pre_release_tag#v}
          IFS='.' read -r major minor patch <<< "$version_without_v"
          # Increment the patch version
          incremented_patch=$((patch + 1))
          new_tag="v$major.$minor.$incremented_patch"
        fi

        echo "Last non-pre-release tag: $last_non_pre_release_tag"
        echo "New tag: $new_tag"
        echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

    - name: Create and push new tag (manual dispatch)
      if: steps.release-type.outputs.manual_dispatch == 'true'
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ steps.last-release-tag.outputs.new_tag }}
        git push origin ${{ steps.last-release-tag.outputs.new_tag }}
        echo "tag_name=${{ steps.last-release-tag.outputs.new_tag }}" >> $GITHUB_OUTPUT
        echo "Created and pushed new tag: ${{ steps.last-release-tag.outputs.new_tag }}"

    - name: Get changelog for this version
      id: changelog
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        TAG_NAME=${{ steps.release-type.outputs.tag_name }}
        VERSION_WITHOUT_V=${TAG_NAME#v}
        
        # Extract changelog section for this version
        if grep -q "## \[$VERSION_WITHOUT_V\]" CHANGELOG.md; then
          # Get the changelog section between this version and the next
          CHANGELOG_SECTION=$(sed -n "/## \[$VERSION_WITHOUT_V\]/,/## \[/p" CHANGELOG.md | sed '$d' | tail -n +2)
          echo "changelog_found=true" >> $GITHUB_OUTPUT
          
          # Save changelog to file for multiline output
          echo "$CHANGELOG_SECTION" > changelog_section.txt
        else
          echo "changelog_found=false" >> $GITHUB_OUTPUT
          echo "No changelog entry found for version $VERSION_WITHOUT_V" > changelog_section.txt
        fi

    - name: Install packaging tools
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        # Install packaging tools
        sudo apt-get update
        sudo apt-get install -y alien rpm genisoimage imagemagick zip wget
        # Install snapcraft
        sudo snap install snapcraft --classic

    - name: Build binaries and packages
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        # Create build directory
        mkdir -p build dist pkg
        
        # Extract version for filename (remove 'v' prefix for some packages)
        VERSION=${{ steps.release-type.outputs.tag_name }}
        VERSION_NO_V=${VERSION#v}
        
        # Build for different platforms with version in filename
        echo "Building for Linux (amd64)..."
        GOOS=linux GOARCH=amd64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-linux-amd64 .
        
        echo "Building for Linux (arm64)..."
        GOOS=linux GOARCH=arm64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-linux-arm64 .
        
        echo "Building for FreeBSD (amd64)..."
        GOOS=freebsd GOARCH=amd64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-freebsd-x64 .
        
        echo "Building for Windows (amd64)..."
        GOOS=windows GOARCH=amd64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-windows-x64.exe .
        
        echo "Building for Windows (arm64)..."
        GOOS=windows GOARCH=arm64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-windows-arm64.exe .
        
        echo "Building for macOS (amd64)..."
        GOOS=darwin GOARCH=amd64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-macos-amd64 .
        
        echo "Building for macOS (arm64)..."
        GOOS=darwin GOARCH=arm64 go build -ldflags "-X main.version=$VERSION" -o build/tala-$VERSION-macos-arm64 .

    - name: Create Linux packages
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        VERSION=${{ steps.release-type.outputs.tag_name }}
        VERSION_NO_V=${VERSION#v}
        
        # Create tar.xz archive for Linux
        echo "Creating tar.xz archive..."
        mkdir -p pkg/tala-$VERSION_NO_V
        cp build/tala-$VERSION-linux-amd64 pkg/tala-$VERSION_NO_V/tala
        cp README.md pkg/tala-$VERSION_NO_V/
        cp CHANGELOG.md pkg/tala-$VERSION_NO_V/
        tar -C pkg -cJf build/tala-$VERSION-linux-x64.tar.xz tala-$VERSION_NO_V
        
        # Create DEB package structure
        echo "Creating DEB package..."
        mkdir -p pkg/deb/usr/local/bin
        mkdir -p pkg/deb/usr/share/doc/tala
        mkdir -p pkg/deb/DEBIAN
        
        cp build/tala-$VERSION-linux-amd64 pkg/deb/usr/local/bin/tala
        chmod +x pkg/deb/usr/local/bin/tala
        cp README.md CHANGELOG.md pkg/deb/usr/share/doc/tala/
        
        # Create control file
        cat > pkg/deb/DEBIAN/control << EOF
        Package: tala
        Version: $VERSION_NO_V
        Section: utils
        Priority: optional
        Architecture: amd64
        Maintainer: Tala Team <noreply@github.com>
        Description: Terminal AI Language Assistant
         Tala is a terminal-based AI language assistant built with Go and Bubble Tea.
         It provides an interactive interface for communicating with various AI providers.
        EOF
        
        dpkg-deb --build pkg/deb build/tala-$VERSION-linux-amd64.deb
        
        # Convert DEB to RPM
        echo "Creating RPM package..."
        cd build
        alien -r -c tala-$VERSION-linux-amd64.deb || echo "RPM creation failed, skipping"
        if ls tala-*.rpm 1> /dev/null 2>&1; then
          mv tala-*.rpm tala-$VERSION-linux-x86_64.rpm
        else
          echo "No RPM file found, creating placeholder"
          touch tala-$VERSION-linux-x86_64.rpm.failed
        fi
        cd ..

    - name: Create Windows packages
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        VERSION=${{ steps.release-type.outputs.tag_name }}
        
        # Create Windows installer (simple zip for now)
        echo "Creating Windows packages..."
        mkdir -p pkg/windows
        cp build/tala-$VERSION-windows-x64.exe pkg/windows/
        cp README.md CHANGELOG.md pkg/windows/
        
        # Create Squirrel.Windows compatible zip
        cd pkg/windows
        zip -r ../../build/tala-$VERSION-squirrel.zip .
        cd ../..
        
        # Create blockmap for exe
        echo "Creating blockmaps..."
        sha256sum build/tala-$VERSION-windows-x64.exe > build/tala-$VERSION-windows-x64.exe.blockmap
        sha256sum build/tala-$VERSION-squirrel.zip > build/tala-$VERSION-squirrel.zip.blockmap

    - name: Create macOS packages
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        VERSION=${{ steps.release-type.outputs.tag_name }}
        
        # Create macOS app bundle structure
        echo "Creating macOS DMG..."
        mkdir -p pkg/macos/Tala.app/Contents/MacOS
        mkdir -p pkg/macos/Tala.app/Contents/Resources
        
        # Create Info.plist
        cat > pkg/macos/Tala.app/Contents/Info.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>tala</string>
            <key>CFBundleIdentifier</key>
            <string>com.github.domykasas.tala</string>
            <key>CFBundleName</key>
            <string>Tala</string>
            <key>CFBundleVersion</key>
            <string>$VERSION</string>
            <key>CFBundleShortVersionString</key>
            <string>$VERSION</string>
        </dict>
        </plist>
        EOF
        
        # Copy universal binary (using amd64 for now)
        cp build/tala-$VERSION-macos-amd64 pkg/macos/Tala.app/Contents/MacOS/tala
        chmod +x pkg/macos/Tala.app/Contents/MacOS/tala
        
        # Create DMG using genisoimage (hdiutil alternative for Linux)
        genisoimage -V "Tala" -D -R -apple -no-pad -o build/tala-$VERSION-macos.dmg pkg/macos
        
        # Create blockmap for DMG
        sha256sum build/tala-$VERSION-macos.dmg > build/tala-$VERSION-macos.dmg.blockmap

    - name: Create AppImage
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        VERSION=${{ steps.release-type.outputs.tag_name }}
        
        echo "Creating AppImage..."
        # Download AppImageTool
        wget -O appimagetool https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
        chmod +x appimagetool
        
        # Create AppDir structure
        mkdir -p pkg/appdir/usr/bin
        mkdir -p pkg/appdir/usr/share/applications
        mkdir -p pkg/appdir/usr/share/icons/hicolor/256x256/apps
        
        # Copy binary
        cp build/tala-$VERSION-linux-amd64 pkg/appdir/usr/bin/tala
        chmod +x pkg/appdir/usr/bin/tala
        
        # Create desktop file
        cat > pkg/appdir/usr/share/applications/tala.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=Tala
        Comment=Terminal AI Language Assistant
        Exec=tala
        Icon=tala
        Categories=Utility;
        Terminal=true
        EOF
        
        # Create simple icon (placeholder)
        echo "Creating placeholder icon..."
        convert -size 256x256 xc:blue -gravity center -pointsize 72 -fill white -annotate +0+0 "T" pkg/appdir/usr/share/icons/hicolor/256x256/apps/tala.png || echo "Warning: ImageMagick not available, skipping icon"
        
        # Copy desktop file to AppDir root
        cp pkg/appdir/usr/share/applications/tala.desktop pkg/appdir/
        cp pkg/appdir/usr/share/icons/hicolor/256x256/apps/tala.png pkg/appdir/ 2>/dev/null || touch pkg/appdir/tala.png
        
        # Create AppImage
        ./appimagetool pkg/appdir build/tala-$VERSION-linux-x86_64.AppImage || echo "AppImage creation failed, skipping"

    - name: Create Snap package
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        VERSION=${{ steps.release-type.outputs.tag_name }}
        
        echo "Creating Snap package..."
        # Update snapcraft.yaml with current version
        sed -i "s/version: git/version: ${VERSION#v}/" snapcraft.yaml
        
        # Build snap with destructive mode to avoid LXD issues in CI
        snapcraft --destructive-mode
        
        # Rename snap to include version
        if ls *.snap 1> /dev/null 2>&1; then
          mv *.snap build/tala-$VERSION-linux-amd64.snap
          echo "Snap package created successfully"
        else
          echo "Snap creation failed, creating placeholder"
          touch build/tala-$VERSION-linux-amd64.snap.failed
        fi

    - name: Create checksums
      if: steps.release-type.outputs.manual_dispatch == 'false'
      run: |
        cd build
        sha256sum * > checksums.txt
        echo "Checksums created:"
        cat checksums.txt

    - name: Read changelog content
      if: steps.release-type.outputs.manual_dispatch == 'false'
      id: changelog-content
      run: |
        if [ -f changelog_section.txt ]; then
          CHANGELOG_CONTENT=$(cat changelog_section.txt)
          echo "changelog_content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo "changelog_content=No changelog entry found for this version." >> $GITHUB_OUTPUT
        fi

    - name: Create Release
      if: steps.release-type.outputs.manual_dispatch == 'false'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release-type.outputs.tag_name }}
        name: ${{ steps.release-type.outputs.release_type }} ${{ steps.release-type.outputs.tag_name }}
        body: |
          ## ${{ steps.release-type.outputs.release_type }} ${{ steps.release-type.outputs.tag_name }}
          
          ### Changes
          
          ${{ steps.changelog-content.outputs.changelog_content }}
          
          ### Downloads
          
          Choose the appropriate package for your platform:
          
          #### Linux
          | Format | Description | Download |
          |--------|-------------|----------|
          | Binary | Standalone executable | `tala-${{ steps.release-type.outputs.tag_name }}-linux-amd64` |
          | DEB | Debian/Ubuntu package | `tala-${{ steps.release-type.outputs.tag_name }}-linux-amd64.deb` |
          | RPM | Red Hat/Fedora package | `tala-${{ steps.release-type.outputs.tag_name }}-linux-x86_64.rpm` |
          | Snap | Universal Linux package | `tala-${{ steps.release-type.outputs.tag_name }}-linux-amd64.snap` |
          | AppImage | Portable Linux package | `tala-${{ steps.release-type.outputs.tag_name }}-linux-x86_64.AppImage` |
          | Archive | Compressed archive | `tala-${{ steps.release-type.outputs.tag_name }}-linux-x64.tar.xz` |
          | ARM64 | ARM64 binary | `tala-${{ steps.release-type.outputs.tag_name }}-linux-arm64` |
          
          #### Windows
          | Format | Description | Download |
          |--------|-------------|----------|
          | Executable | Windows installer | `tala-${{ steps.release-type.outputs.tag_name }}-windows-x64.exe` |
          | Squirrel | Auto-updater package | `tala-${{ steps.release-type.outputs.tag_name }}-squirrel.zip` |
          | ARM64 | ARM64 executable | `tala-${{ steps.release-type.outputs.tag_name }}-windows-arm64.exe` |
          
          #### macOS
          | Format | Description | Download |
          |--------|-------------|----------|
          | DMG | macOS disk image | `tala-${{ steps.release-type.outputs.tag_name }}-macos.dmg` |
          | Intel | Intel binary | `tala-${{ steps.release-type.outputs.tag_name }}-macos-amd64` |
          | Apple Silicon | ARM64 binary | `tala-${{ steps.release-type.outputs.tag_name }}-macos-arm64` |
          
          #### FreeBSD
          | Format | Description | Download |
          |--------|-------------|----------|
          | Binary | FreeBSD executable | `tala-${{ steps.release-type.outputs.tag_name }}-freebsd-x64` |
          
          ### Installation
          
          **Linux/macOS:**
          ```bash
          # Download the binary for your platform
          chmod +x tala-*
          ./tala-*
          ```
          
          **Windows:**
          ```cmd
          # Download the .exe file for your platform
          tala-windows-*.exe
          ```
          
          ### Prerequisites
          
          - For default setup: [Ollama](https://ollama.ai) with deepseek-r1 model
          - For OpenAI/Anthropic: Valid API keys
          
          ### Quick Start
          
          ```bash
          # Install Ollama and pull model (for default setup)
          ollama serve
          ollama pull deepseek-r1
          
          # Run Tala
          ./tala-*
          ```
          
          ### Verification
          
          Verify your download using the provided checksums:
          ```bash
          sha256sum -c checksums.txt
          ```
          
          ---
          
          ${{ steps.release-type.outputs.is_prerelease == 'true' && '**Note**: This is a pre-release version and may contain bugs. Use for testing purposes only.' || 'For support and documentation, visit the [repository](https://github.com/domykasas/tala).' }}
        files: build/*
        draft: false
        prerelease: ${{ steps.release-type.outputs.is_prerelease }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

